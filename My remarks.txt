1- Do not forget to uncomment the lines in worker.py that start with:
    if self.device == "cuda":...
We erased it for running tuning.py

2- 1e-2 seems to be a good learning rate (with the clipping 1.5)

if "corr" in method: # CD-SGD
                        # Determining the couples (sigma, sigma_cor) that can be considered
                        sigmas_df = pd.DataFrame(columns = ["topology", "sigma", "sigma-cor", "epsilon"])
                        sigma_grid = np.linspace(sigma_cdp, sigma_ldp, 50)
                        sigma_cor_grid = np.linspace(1, 1000, 1000)
                        for sigma in sigma_grid:
                            all_sigma_cor = plotting.find_sigma_cor(sigma, sigma_cor_grid, params["gradient-clip"], degree_matrix, adjacency_matrix, eps_iter)
                            #tools.success(all_sigma_cor)
                            # check non-emptyness and add it
                            if len(all_sigma_cor) !=0:
                
                                new_row = {"topology": topology_name,
                                           "sigma": sigma,
                                           "sigma-cor": all_sigma_cor[0],
                                           "epsilon": target_eps}
                                sigmas_df = pd.concat([sigmas_df, pd.DataFrame([new_row])], ignore_index=True)

                        # Store result of ooking for sigmas
                        filename = f'result_grid_corr_epsilon_{target_eps}.csv'
                        sigmas_df.to_csv(filename)

                        # Taking the values on the first row (correspond to the least sigma)
                        params["sigma"] = sigmas_df.iloc[0]["sigma"]
                        params["sigma-cor"]= sigmas_df.iloc[0]["sigma-cor"]

Steps to follow to organize our work:
- Launch simulations with MNIST and store them in Data
- Once we have all results, we plot them in the way we want (loss in function of Epsilon and with desired colors)
- Implement training of LibSVM, and once we can do it correctly, we include it in our codebase
- Organize all plots and keep data to fill tables
- That's it !